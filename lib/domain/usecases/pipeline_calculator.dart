import 'dart:math';

import '../entities/tech_tree.dart';

class PipelineResult {
  final double noiseProduced;
  final double filterConsumed;
  final double signalProduced;
  final double overheatGenerated;

  const PipelineResult({
    required this.noiseProduced,
    required this.filterConsumed,
    required this.signalProduced,
    required this.overheatGenerated,
  });
}

class PipelineCalculator {
  /// Calculates the raw noise production rate per second based on generators and multipliers.
  static double calculateNoiseRate({
    required double baseProduction,
    required int generatorCount,
    required double currentMomentum, // Mom_curr
    required TechTree techTree,
  }) {
    double rate = baseProduction * generatorCount * currentMomentum;

    // Entropy Manipulation - Equilibrium Destruction (Tree 3.1)
    if (techTree.equilibriumDestructionUnlocked) {
      rate *= 5.0; // 5x Global Noise
    }

    return rate;
  }

  /// Calculates the effective filter processing capacity per second.
  static double calculateFilterCapacity({
    required double baseCapacity,
    required int filterCount,
    required int generatorCount,
    required TechTree techTree,
  }) {
    double capacity = baseCapacity * filterCount;

    // Cognitive Empathy - Echo Synergy (Tree 2.2)
    // Every 10 generators adds +0.5% (0.005) passive capacity
    if (techTree.echoSynergyUnlocked) {
      int setsOf10 = generatorCount ~/ 10;
      double bonus = setsOf10 * 0.005;
      capacity *= (1.0 + bonus);
    }

    return capacity;
  }

  /// Processes a single tick calculating production and bottleneck penalties
  static PipelineResult processTick({
    required double dt,
    required double noiseRate, // N_rate
    required double filterRate, // F_rate (capacity per second)
    required double filterEfficiency, // F_eff
    required double currentNoiseState,
    required bool isThrottling,
    required TechTree techTree,
  }) {
    // If Thermal Throttling is active, efficiency plummets or halts entirely.
    double activeEfficiency = isThrottling
        ? 0.1
        : filterEfficiency; // drops to 10%
    double activeFilterRate = isThrottling ? filterRate * 0.1 : filterRate;

    // 1. Noise Produced
    double noiseProducedThisTick = noiseRate * dt;
    double totalAvailableNoise = currentNoiseState + noiseProducedThisTick;

    // 2. Filter Capacity this tick
    double filterCapacityThisTick = activeFilterRate * dt;

    // 3. Bottleneck and Consumption
    double noiseConsumed = min(totalAvailableNoise, filterCapacityThisTick);

    // 4. Signal Production
    double signalProduced = noiseConsumed * activeEfficiency;

    // Tree 3.1 - Equilibrium Destruction
    if (techTree.equilibriumDestructionUnlocked && !isThrottling) {
      signalProduced *= 5.0; // 5x Global Signal
    }

    // 5. Overheat Generation
    // Overheat is generated by the excess noise production rate that exceeds filter rate
    double overheatGenerated = 0.0;
    if (noiseRate > activeFilterRate) {
      // Only accumulate heat if producing more than can be handled
      overheatGenerated = (noiseRate - activeFilterRate) * dt;
    }

    return PipelineResult(
      noiseProduced: noiseProducedThisTick,
      filterConsumed: noiseConsumed,
      signalProduced: signalProduced,
      overheatGenerated: overheatGenerated,
    );
  }
}
